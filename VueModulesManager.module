<?php namespace ProcessWire;

/**
 * Class ProcessModuleInstall
 *
 * Provides methods for internative module installation for ProcessModule
 *
 * extended version for AdminThemeUikit and ProcessWire 3.x in 2019 by Jens Martsch
 * based on ProcessWire Modules Manager created 2012 by Soma
 *
 */
class VueModulesManager extends Process implements ConfigurableModule
{

    protected static $defaults = array(
        'apikey' => 'pw223',
        'remoteurl' => 'http://modules.processwire.com/export-json/',
        'limit' => 350,
        'max_redirects' => 3,
    );

    // uninstallable
    protected $exclude_categories = array(
        'language-pack' => 'Language Packs',
        'site-profile' => 'Site Profiles',
        'premium' => 'Premium Modules',
    );

    protected $modulesArray = array();
    protected $modulesRemoteArray = array();
    protected $downloadFileName = 'ModuleManagerDownload.zip';

    public $cachefile = 'ModuleManager.cache';

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     *
     */
    public static function getModuleInfo()
    {
        return array(
            'title' => 'Vue Modules Manager',
            'version' => "0.0.1",
            'summary' => 'Browse Modules from modules.processwire.com. Download, update or install them.',
            'href' => '/',
            'author' => "Jens Martsch",
            'singular' => true,
            'autoload' => false,
            'permission' => 'modules-manager',
        );
    }

    public function __construct()
    {
        $this->labels['download'] = $this->_('Download');
        if ($this->input->get->update) {
            $this->labels['download_install'] = $this->_('Download and Update');
        } else {
            $this->labels['download_install'] = $this->_('Download and Install');
        }
        $this->labels['get_module_info'] = $this->_('Get Module Info');
        $this->labels['module_information'] = $this->_x("Module Information", 'edit');
        $this->labels['download_now'] = $this->_('Download Now');
        $this->labels['download_dir'] = $this->_('Add Module From Directory');
        $this->labels['upload'] = $this->_('Upload');
        $this->labels['upload_zip'] = $this->_('Add Module From Upload');
        $this->labels['download_zip'] = $this->_('Add Module From URL');
        $this->labels['check_new'] = $this->_('Check for New Modules');
        $this->labels['installed_date'] = $this->_('Installed');
        $this->labels['requires'] = $this->_x("Requires", 'list'); // Label that precedes list of required prerequisite modules
        $this->labels['installs'] = $this->_x("Also Installs", 'list'); // Label that precedes list of other modules a given one installs
        $this->labels['reset'] = $this->_('Refresh');
        $this->labels['core'] = $this->_('Core');
        $this->labels['site'] = $this->_('Site');
        $this->labels['configure'] = $this->_('Configure');
        $this->labels['install_btn'] = $this->_x('Install', 'button'); // Label for Install button
        $this->labels['install'] = $this->_('Install'); // Label for Install tab
        $this->labels['cancel'] = $this->_('Cancel'); // Label for Cancel button

        if ($this->wire('languages') && !$this->wire('user')->language->isDefault()) {
            // Use previous translations when new labels aren't available (can be removed in PW 2.6+ when language packs assumed updated)
            if ($this->labels['install'] == 'Install') {
                $this->labels['install'] = $this->labels['install_btn'];
            }

            if ($this->labels['reset'] == 'Refresh') {
                $this->labels['reset'] = $this->labels['check_new'];
            }

        }
    }

    /**
     * get the config either default or overwritten by user config
     * @param string $key name of the option
     * @return mixed      return requested option value
     */
    public function getConfig($key)
    {
        return ($this->get($key)) ? $this->get($key) : self::$defaults[$key];
    }

    /**
     * this method is called when ProcessWire is read and loaded the module
     * used here to get scripts and css files loaded automatically
     */
    public function init()
    {
        parent::init();

        $this->use_modal = '';
        if ($this->modules->isInstalled("JqueryMagnific")) {
            $this->modules->JqueryMagnific;
            $this->use_modal = true;
            $this->modal = "&pw-panel=1";
            $this->config->js("process_modulesmanager_lightbox", "magnific");
        } else {
            if ($this->modules->isInstalled("JqueryFancybox")) {
                $this->modules->JqueryFancybox;
                $this->use_modal = true;
                $this->modal = "&modal=1";
                $this->config->js("process_modulesmanager_lightbox", "fancybox");
            }
        }

        // $this->set('cachefile','ModuleManager.cache');

        $this->labelRequires = $this->_x("Requires", 'list'); // Label that precedes list of required prerequisite modules
        $this->labelInstalls = $this->_x("Also installs", 'list'); // Label that precedes list of required prerequisite modules

        // get current installed modules in PW and store it in array
        // for later use to generate
        foreach ($this->modules as $module) {
            $this->modulesArray[$module->className()] = 1;
            wire('modules')->getModuleInfo($module->className()); // fixes problems
        }
        // get current uninstalled modules with flag 0
        foreach ($this->modules->getInstallable() as $module) {
            $this->modulesArray[basename($module, '.module')] = 0;
            wire('modules')->getModuleInfo(basename($module, '.module')); // fixes problems
        }

    }

    public function initModules()
    {
        // WORKAROUND FIX: cycle all modules to load them without installing them
        // so we can getModuleInfo(classname) to work for extending modules of modules that aren't yet installed/loaded
        // so dependencies for "requires" can be checked for modules that are downloaded
        foreach ($this->modules as $module) {
            wire('modules')->getModuleInfo($module->className()); // fixes problems
        }
        // get current uninstalled modules with flag 0
        foreach ($this->modules->getInstallable() as $module) {
            wire('modules')->getModuleInfo(basename($module, '.module')); // fixes problems
        }
    }

    /**
     * Format a module version number from 999 to 9.9.9
     *
     * @param string $version
     * @return string
     *
     */
    protected function formatVersion($version)
    {
        return $this->wire('modules')->formatVersion($version);
    }

    /**
     * Display the default admin screen with module list
     *
     * @return string output html string
     */
    public function execute()
    {

        // check if we have the rights to download files from other domains
        // using copy or file_get_contents
        if (!ini_get('allow_url_fopen')) {
            $this->error($this->_('The php config `allow_url_fopen` is disabled on the server, modules cannot be downloaded through Modules Manager. Enable it or ask your hosting support then try again.'));
        }

        // check if directories are writeable
        if (!is_writable($this->config->paths->assets)) {
            $this->error($this->_('Make sure your /site/assets directory is writable by PHP.'));
        }
        if (!is_writable($this->config->paths->siteModules)) {
            $this->error($this->_('Make sure your /site/modules directory is writable by PHP.'));
        }

        // reset cache to scan for new modules downloaded, manually
        // put into site modules folder and download current JSON feed
        if ($this->input->get->reset) {
            // reset PW modules cache
            $this->modules->resetCache();
            // json feed download and cache
            $this->createCacheFile();
            // reload page without params
            $this->session->redirect('./');
        }

        // output javascript config vars used by ModulesManager.js
//        $this->config->scripts->add("https://cdn.jsdelivr.net/npm/vue/dist/vue.js");
//        $this->config->scripts->add("https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js");
//        $this->config->styles->add("https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css");

//        $this->config->scripts->add("https://unpkg.com/vue-multiselect@2.1.0");
        $this->config->styles->add("https://unpkg.com/vue-multiselect@2.1.0/dist/vue-multiselect.min.css");

//        $this->config->scripts->add($this->config->urls->VueModulesManager . 'dist/js/chunk-vendors.js');
//        $this->config->scripts->add($this->config->urls->VueModulesManager . 'dist/js/main.js');

        $this->config->js("process_modulesmanager", $this->pages->get("parent=22,name=modulesmanager")->url . "getdata/");
        $this->config->js("process_modulesmanager_filter_cat", $this->input->get->cat);

        // get json module feed cache file,
        // if not yet cached download and cache it
        if (file_exists($this->config->paths->cache . $this->cachefile)) {
            $this->modulesRemoteArray = $this->readCacheFile();
        } else {
            $this->modulesRemoteArray = $this->createCacheFile();
        }

        $count = 0;
        $this->all_categories = array();

        // loop the module list we got from the json feed and we do
        // various checks here to see if it's up to date or installed
        foreach ($this->modulesRemoteArray->items as $key => $module) {

            $categories = array();

            foreach ($module->categories as $cat) {
                $categories[$cat->name] = $cat->title;
            }

            //$all_categories = array_merge($all_categories, $categories);
            $this->all_categories = array_merge($this->all_categories, $categories);

            $filterout = false;

            // filter for selected category
            if (isset(wire('input')->get->cat)) {
                $selected_cat = wire('input')->get->cat;
                if ($selected_cat) {
                    if (!array_key_exists(wire('input')->get->cat, $categories)) {
                        $filterout = true;
                    }
                }
            }

            if (!$filterout) {
                $count++;
            }

        }

        $categories_form = $this->createCategoryForm()->render();

        $this->modules_found = '<p>' . sprintf($this->_("%d modules found in this category on modules.processwire.com"), $count) . '</p>';
        //$pretext .= 'ProcessWire Version ' . $this->config->version;
        $info = $this->getModuleInfo();

        $form = $this->createForm()->render();

        return $form . '<p>Modules Manager v' . $info['version'] . '</p>';
    }

    public function executeDownload()
    {

        $this->modules->resetCache();

        $url = $this->input->get->url;
        $class_name = $this->input->get->class;

        $tmp_dir = $this->config->paths->assets;
        $tmp_zip = $tmp_dir . $this->downloadFileName;

        if (!is_writable($this->config->paths->assets)) {
            $this->error($this->_('Make sure assets directory is writeable for PHP.'));
        }

        if (!is_writable($this->config->paths->siteModules)) {
            $this->error($this->_('Make sure your site modules directory is writable for PHP.'));
        }

        // download the zip file and save it in assets directory
        $success = false;

        if ($file = $this->downloadFile($url, $tmp_zip)) {
            $this->message('Downloaded zip file successfully from ' . $url);
            // if successfully downloaded extract it
            $zip = new ZipArchive;
            if ($zip->open($file) === true) {
                for ($i = 0; $i < $zip->numFiles; $i++) {
                    $zip->extractTo($tmp_dir, array($zip->getNameIndex($i)));
                }
                $extracted_directory_name = trim($zip->getNameIndex(0), '/');
                $zip->close();
            } else {
                throw new WireException('Could not open zip file');
            }
            // now create module directory and copy files over
            // if it's an admin theme we place it in site folder or remove current
            // if any found
            if ($this->input->get('theme')) {
                // look for a templates-admin folder
                if (glob($tmp_dir . $extracted_directory_name . '/templates-admin', GLOB_ONLYDIR)) {
                    $from = $tmp_dir . $extracted_directory_name . '/templates-admin/';
                } else {
                    $from = $tmp_dir . $extracted_directory_name . '/';
                }
                $destination_directory = $this->config->paths->root . 'site/templates-admin';

                // remove the templates-admin folder if present
                if (file_exists($destination_directory)) {
                    if (strlen($destination_directory) > 0) {
                        if (!$this->removeDir($destination_directory)) {
                            throw new WireException('Could not remove templates-admin folder in site folder');
                        }

                    }
                }
            } else {
                $from = $tmp_dir . $extracted_directory_name . '/';
                $destination_directory = $this->config->paths->siteModules . $class_name;
            }
            if ($this->createDirectory($destination_directory)) {
                if ($this->recursiveCopy($from, $destination_directory)) {
                    $this->message('Successfully copied files  to the directory: ' . $destination_directory);
                    $success = true;
                }
            } else {
                $this->error('Could not create directory: ' . $destination_directory);
            }

            // remove downloaded zip and extracted folder
            if (!unlink($tmp_zip)) {
                throw new WireException('Could not delete downloaded zip file ' . $tmp_zip);
            }

            if (strlen($extracted_directory_name) > 0) {
                if (!$this->removeDir($tmp_dir . $extracted_directory_name)) {
                    throw new WireException('Could not delete downloaded temporary files ' . $tmp_dir . $extracted_directory_name);
                }

            }

        }

        // downloading and extracting is successful
        // lets show some install information
        if (!$success) {
            return '<p>' . $this->_('There seems to be a problem with downloading or writing the module.') . '</p>';
        }

        // reset modules cache, so we can install the module and PW knows about it
        $this->modules->resetCache();

        if ($this->input->get('theme')) {
            $str = sprintf($this->_('Admin theme `%s` downloaded and extracted successfully. If it worked you should see the new theme already. If not you may clear your cache or refresh the page.'), $class_name);
            $text = '<p>' . $str . '</p>';
            return $text;
        }

        // check if modules isn't already installed and this isn't an update
        if (!$this->modules->isInstalled($class_name)) {
            $this->session->redirect("../install/?class=$class_name{$this->modal}");
        } else {
            $this->fuel->set('processHeadline', 'You just updated ' . $class_name);
            $str = sprintf($this->_('Module `%s` was updated successfully. Ready to check if everything still work! Or if there are possibly new options.'), $class_name);
            $text = '<p>' . $str . ' Module: <a href="' . $this->pages->get(21)->url . 'edit?name=' . $class_name . '">' . $class_name . '</a></p>';
        }
        return $text;
    }

    public function executeInstall()
    {

        $this->initModules(); // fix problems with modules extending modules not yet installed

        $class_name = $this->input->get->class;
        if (!$class_name) {
            return $this->_("No class name found in GET parameter");
        }

        $this->fuel->set('processHeadline', $this->_("Module Download Page"));

        $ptitle = sprintf($this->_("Downloaded: '%s'"), $class_name);
        $text = "<h2>$ptitle</h2>";

        $str = $this->_('Module downloaded and extracted successfully. If the modules allows it you can install it directly from here or any time later on the Modules admin page.');
        $text .= '<p>' . $str . '</p>';

        $info = $this->modules->getModuleInfo($class_name);

        if (count($info['requires'])) {
            $requires = $this->modules->getRequiresForInstall("ProcessLanguageTranslatorPlus");
            if (count($requires)) {
                $text .= "<p><b>" . $this->_("Sorry, you can't install this module now. It requires other module to be installed first") . ":</b><br/>";
                $text .= "<span class='notes'>$this->labelRequires - " . implode(', ', $requires) . "</span></p>";
            }
        } else {
            $requires = array();
        }

        $form = $this->modules->get('InputfieldForm');
        $form->attr('action', $this->pages->get(21)->url);
        $form->attr('method', 'post');
        $form->attr('id', 'modules_form');

        $field = '<input type="hidden" name="install" value="' . $class_name . '"/>';
        $form->value .= $field;

        if (!count($requires)) {
            $submit = $this->modules->get('InputfieldSubmit');
            $submit->attr('name', 'submit');
            $submit->attr('value', $this->_('install module'));
            $submit->columnWidth = 50;
            $form->add($submit);
        }

        // $button = $this->modules->get('InputfieldButton');
        // $button->attr('href', '../');
        // $button->attr('value', $this->_('back to Modules Manager'));
        // $button->attr('id', 'backtomanagerbutton');
        // $button->columnWidth = 100;
        // $form->add($button);

        $text .= $form->render();

        return $text;
    }

    /**
     * Install module and redirect to edit screen
     * Same a ProcessModule does but without post, so we can use it with modules manager
     * more easily
     */
    public function executeInstallModule()
    {
        $name = $this->input->get->install;
        if ($name && isset($this->modulesArray[$name]) && !$this->modulesArray[$name]) {
            $module = $this->modules->get($name);
            $this->modulesArray[$name] = 1;
            $this->session->message($this->_("Module Install") . " - " . $module->className); // Message that precedes the name of the module installed
            $this->session->redirect($this->config->urls->admin . "module/edit?name={$module->className}");
        }
    }

    /**
     * Provides url method to get data for DataTables
     * @return string the json string needed by DataTables plugin
     */
    public function executeGetData()
    {

        $this->modules->resetCache();

        // get json module feed cache file,
        // if not yet cached download and cache it
        if (file_exists($this->config->paths->cache . $this->cachefile)) {
            $this->modulesRemoteArray = $this->readCacheFile();
        } else {
            $this->modulesRemoteArray = $this->createCacheFile();
        }

        // get current installed modules in PW and store it in array
        // for later use to generate
        foreach ($this->modules as $module) {
            $this->modulesArray[$module->className()] = 1;
            wire('modules')->getModuleInfo($module->className()); // fixes problems
        }
        // get current uninstalled modules with flag 0
        foreach ($this->modules->getInstallable() as $module) {
            $this->modulesArray[basename($module, '.module')] = 0;
            wire('modules')->getModuleInfo(basename($module, '.module')); // fixes problems
        }

        $out = [];
        $count = 0;
        $this->all_categories = array();

        // loop the module list we got from the json feed and we do
        // various checks here to see if it's up to date or installed
        foreach ($this->modulesRemoteArray->items as $key => $module) {

            $categories = array();

            foreach ($module->categories as $cat) {
                $categories[$cat->name] = $cat->title;
            }

            //$all_categories = array_merge($all_categories, $categories);
            $this->all_categories = array_merge($this->all_categories, $categories);

            // exclude modules
            $uninstallable = false;
            $filterout = false;

            // filter out unwanted categories
            foreach ($this->exclude_categories as $k => $exc) {
                if (array_key_exists($k, $categories)) {
                    $uninstallable = true;
                    break;
                }
            }

            // filter for selected category
            if (isset(wire('input')->get->cat)) {
                $selected_cat = wire('input')->get->cat;
                if ($selected_cat) {
                    if (!array_key_exists(wire('input')->get->cat, $categories)) {
                        $filterout = true;
                    }
                }
            }

            // if filtered out no need to go any further in the loop
            if ($filterout) {
                continue;
            }

            // lets add a link to the modules.processwire.com instead

            $count++;
            // $module = (array)$module;
            array_push($out, $this->createItemRow($module, $uninstallable));

        }
        return json_encode($out);
    }

    public function createItemRow($item, $uninstallable)
    {

        $remote_version = $this->formatVersion($item->module_version);

        $item->status = '';
        $item->version = '-';
        $item->actions = '-';
        $item->dependencies = '';

        if (array_key_exists($item->class_name, $this->modulesArray)) {

            // get module infos, we can't use modules->get(module_name) here
            // as it would install the module, which we don't want at all
            $info = wire('modules')->getModuleInfo($item->class_name);
            $this->local_version = $this->formatVersion($info['version']);

            if ($this->modulesArray[$item->class_name] == 0) {

                if (count($info['requires'])) {
                    $requires = $this->modules->getRequiresForInstall($item->class_name);
                    if (count($requires)) {
                        $item->dependencies .= "<br /><span class='notes'>$this->labelRequires - " . implode(', ', $requires) . "</span>";
                    }

                } else {
                    $requires = array();
                }

                if (count($info['installs'])) {
                    $item->dependencies .= "<br /><span class='detail'>$this->labelInstalls - " . implode(', ', $info['installs']) . "</span>";
                }

                $item->status = '<span class="uk-text-muted">' . $this->_('not installed') . ': ' . $this->local_version . '</span>';

                if (count($requires)) {
                    $item->actions = $this->getActions($item, $uninstallable, 'not_install');
                } else {
                    $item->actions = $this->getActions($item, $uninstallable, 'install');
                }
            } else {
                if ($remote_version > $this->local_version) {
                    $item->status = '<span class="uk-text-success">' . $this->_('installed') . ': ' . $this->local_version . '</span><br/>';
                    $item->status .= '<span class="ui-state-update">' . $this->_("new version available!") . '</span><br/>';

                    $item->actions = $this->getActions($item, $uninstallable, 'update');

                } else {
                    $item->status = '<span class="uk-text-primary">' . $this->_('installed') . ': ' . $this->local_version . '</span>';
                    $item->actions = $this->getActions($item, $uninstallable, 'edit');
                }
            }
        } else {
            $item->theme = isset($categories['admin-theme']) ? '&theme=1' : '';
            $item->actions = $this->getActions($item, $uninstallable, 'download', $item->theme);
        }

        $categories = array();
        foreach ($item->categories as $category) {
            $categories[] = $category->title;
        }

        // $item->categories = implode(", ", $categories);

        $authors = array();
        foreach ($item->authors as $auth) {
            $authors[] = $auth->title;
        }

        $item->authors = implode(", ", $authors);
        $item->created = date("Y/m/d", $item->created);
        $item->modified = date("Y/m/d", $item->modified);
        return (array)$item;
    }

    public function createModuleOverview()
    {
        $data = $this->executeGetData();
        bd($data);
        $categories = array_merge($this->all_categories, array('' => ''));
        $category_markup = '';
        foreach ($categories as $key => $value) {
            $category_markup .= "<li uk-filter-control='.$key'><a href='#'>$value</a></li>";
        }

        $additional_info = <<<EOD
        <p>ClassName: {{ module.class_name }}</p>
                        <p>Created {{ module.created }}<br>
                        Last modified {{ module.modified }}</p>
                        <p>Categories:
                        <span v-for="(category, index) in module.categories">
                            <a :href="category.url">{{ category.title }}</a><span v-if="index+1 < module.categories.length">, </span>
                        </span>
                        </p>
                        <p>Compatible with PW versions:<br> 
                         <span v-for="(version, index) in module.pw_versions">
                            {{ version.title }}<span v-if="index+1 < module.pw_versions.length">, </span>
                        </span>
                        </p>
EOD;

        $markup .= <<<EOD
        {$this->modules_found}
        <script>window.modules = $data;</script>
        <div id="app">Modules appear here</div>
        <script src="{$this->config->urls->VueModulesManager}dist/js/chunk-vendors.js"></script>
        <script src="{$this->config->urls->VueModulesManager}dist/js/main.js"></script>
EOD;
        return $markup;
    }

    public function createForm()
    {
        // build form
        $form = $this->modules->get('InputfieldForm');
        $form->attr('action', $this->pages->get(21)->url);
        $form->attr('method', 'post');
        $form->attr('id', 'modules_form');

        // refresh button
        $submit = $this->modules->get('InputfieldButton');
        $submit->attr('href', './?reset=1');
        $submit->attr('name', 'reset');
        $submit->attr('value', $this->_('refresh'));
        $submit->attr('class', $submit->attr('class') . ' head_button_clone');
        $form->add($submit);

        $moduleOverview = $this->createModuleOverview();
        $form->attr('value', $moduleOverview);

        return $form;
    }

    public function createCategoryForm()
    {

        // category select filter
        $categories_form = $this->modules->get('InputfieldForm');
        $categories_form->attr('action', './');
        $categories_form->attr('method', 'get');
        $categories_form->attr('uk-sticky', 'true');
        $categories_form->attr('id', 'modules_filter_form');

        // category select
        $cats = $this->modules->get('InputfieldSelect');
        $cats->attr('id+name', 'cat');
        $cats->label = $this->_('Filter categories');
        $categories = array_merge($this->all_categories, array('' => ''));

        bd($categories);
        //$all_categories = array_diff($all_categories, $this->exclude_categories);
        ksort($categories);

        $cats->addOptions($categories);
        $cats->value = wire('input')->get->cat; // selected the current requested GET
        $cats->attr('onchange', 'submit()');
        $cats->columnWidth = 100;
        $categories_form->append($cats);

        return $categories_form;
    }

    private function getActions($module, $uninstallable, $action = '', $theme = '')
    {

        $no_install_txt = $this->_("Uninstallable with Modules Manager");
        $uninstallable_txt = $this->_("uninstallable");
        $install_text = $this->_("install");
        $no_url_found_text = $this->_("No download URL found");

        if ($uninstallable) {
            return '(' . $uninstallable_txt . ')<br/><a href="' . $module->url . '" target="_blank" title="' . $no_install_txt . '">' . $this->_("more") . '</a>';
        }

        $confirm = '';

        if ($theme) {
            $install_confirm_text = $this->_('This will install the theme and delete the previous! If you have altered the /site/templates-admin/ theme or have your own, you might consider backing it up first.');
        } else {
            $install_confirm_text = $this->_('Ensure that you trust the source of the ZIP file before continuing!');
        }

        if ($module->download_url) {
            if (substr($module->download_url, 0, 8) == 'https://' && !extension_loaded('openssl')) {
                $actions = 'no openssl installed!';
            } else {
                $button = $this->modules->get('InputfieldMarkup');
                if ($action == 'edit') {
                    $url = "{$this->pages->get(21)->url}edit?name={$module->class_name}$this->modal";
                    $button->value = "<a href='$url' id='{$module->class_name}' class='uk-button uk-button-default uk-button-small'><i class='fa fa-cog'></i> " . $this->_("edit") . "</a>";
                }
                if ($action == 'update') {
                    $url = "{$this->page->url}download/?url=" . urlencode($module->download_url) . "&class={$module->class_name}{$theme}$this->modal";
                    $button->value = "<a href='$url' class='confirm uk-button uk-button-default uk-button-small' data-confirmtext='$install_confirm_text' id='{$module->class_name}'><i class='fa fa-arrow-circle-up'></i> " . $this->_("update") . "</a>";
                }
                if ($action == 'download') {
                    $url = "{$this->page->url}download/?url=" . urlencode($module->download_url) . "&class={$module->class_name}{$theme}$this->modal";
                    $button->value = "<a href='$url' class='confirm uk-button uk-button-default uk-button-small' data-confirmtext='$install_confirm_text' id='{$module->class_name}'><i class='fa cloud-download-alt'></i> " . $this->_("download") . "</a>";
                }
                if ($action == 'install') {
                    $install_url = $this->page->url . "installmodule/?install={$module->class_name}" . $this->modal;
                    $button->value = "<a href='{$install_url}'>" . $install_text . "</a>";
                }
                if ($action == 'not_install') {
                    $button->value = "<a href='#'><s>" . $install_text . "</s></a>";
                }

                $actions = $button->render();
            }
        } else {
            // in case a module has no dl url but is already downloaded and can be installed
            if ($this->modules->isInstallable($module->class_name)) {
                $actions = "<button name='install' value='{$module->class_name}' class='uk-button uk-button-default uk-button-small'><i class='fa fa-toggle-on'></i> " . $install_text . "</button>";
            } else {
                $more = $this->_("info");
                $actions = "<a href='$module->url' target='_blank' title='$no_url_found_text' class='uk-button uk-button-default uk-button-small'><i class='fa fa-info-circle'></i> $more</a>";
            }
        }
        return $actions;
    }

    private function downloadFile($url, $fileName)
    {

        if ((substr($url, 0, 8) == 'https://') && !extension_loaded('openssl')) {
            $this->error('OpenSSL extension required but not available. File could not be downloaded from ' . $url);
            return false;
        }

        // Define the options
        $options = array('max_redirects' => $this->getConfig('max_redirects'));
        $context = stream_context_create(array('http' => $options));

        // download the zip
        if (!$content = file_get_contents($url, $fileName, $context)) {
            $this->error('File could not be downloaded ' . $url);
            return false;
        }

        if (($fp = fopen($fileName, 'wb')) === false) {
            $this->error('fopen error for filename ' . $fileName);
            return false;
        }

        fwrite($fp, $content);
        fclose($fp);
        return $fileName;
    }

    private function recursiveCopy($source_directory, $destination_directory)
    {
        // recursive function to copy
        // all subdirectories and contents:
        if (is_dir($source_directory)) {
            $directory_handle = opendir($source_directory);
        }

        $directory_name = substr($source_directory, strrpos($source_directory, '/') + 1);

        wireMkdir($destination_directory . '/' . $directory_name);
        if ($directory_handle != false) {
            while ($file = readdir($directory_handle)) {
                if ($file != '.' && $file != '..') {
                    if (!is_dir($source_directory . '/' . $file)) {
                        copy($source_directory . '/' . $file, $destination_directory . $directory_name . '/' . $file);
                    } else {
                        $this->recursiveCopy($source_directory . '/' . $file, $destination_directory . $directory_name . '/');
                    }
                }
            }
            closedir($directory_handle);
        }
        return true;
    }

    private function createDirectory($directory)
    {
        if (!file_exists($directory)) {
            if (!wireMkdir($directory)) {
                $this->error('error creating module directory at: ' . $directory);
                return false;
            }
        } else {
            if (!$this->removeDir($directory)) {
                return false;
            }
        }
        return true;
    }

    private function removeDir($dir)
    {
        foreach (scandir($dir) as $file) {
            if ($file === '.' || $file === '..') {
                continue;
            }

            if (is_dir($dir . '/' . $file)) {
                $this->removeDir($dir . '/' . $file);
            } else {
                if (!unlink($dir . '/' . $file)) {
                    throw new WireException('Could not remove file ' . $file);
                }

            }
        }
        if (!rmdir($dir)) {
            throw new WireException('Could not remove directory ' . $dir);
        }

        return true;
    }

    public function createCacheFile($cache_file = '')
    {
        if (!$cache_file) {
            $cache_file = $this->config->paths->cache . $this->cachefile;
        }

        $contents = file_get_contents($this->getConfig('remoteurl') . '?apikey=' . $this->getConfig('apikey') . '&limit=' . $this->getConfig('limit'));
        if (!$handle = fopen($cache_file, 'w')) {
            throw new WireException('cannot create cache file ' . $cache_file);
        }

        if (!fwrite($handle, $contents)) {
            throw new WireException('cannot write cache file ' . $cache_file);
        }

        fclose($handle);
        return json_decode($contents);
    }

    public function readCacheFile($cache_file = '')
    {
        if (!$cache_file) {
            $cache_file = $this->config->paths->cache . $this->cachefile;
        }

        if (!$handle = fopen($cache_file, 'r')) {
            throw new WireException('cannot open cache file ' . $cache_file);
        }

        if (!$contents = fread($handle, filesize($cache_file))) {
            throw new WireException('cannot read cache file ' . $cache_file);
        }

        fclose($handle);
        return json_decode($contents);
    }

    public function install()
    {
        // page already found for some reason
        $ap = $this->pages->find('name=' . __CLASS__)->first();
        if ($ap->id) {
            if (!$ap->process) {
                $ap->process = $this;
                $ap->save();
            }
            return;
        }
        $p = new Page();
        $p->template = $this->templates->get('admin');
        $p->title = __CLASS__;
        $p->name = __CLASS__;
        $p->parent = $this->pages->get(22);
        $p->process = $this;
        $p->save();
    }

    public function uninstall()
    {
        $found = $this->pages->find('name=' . __CLASS__)->first();
        if ($found->id) {
            $found->delete();
        }

        $cache_file = $this->config->paths->cache . $this->cachefile;
        if (file_exists($cache_file)) {
            if (!unlink($cache_file)) {
                throw new WireException('Could not delete cache file ' . $cache_file);
            } else {
                $this->message('Cache file deleted successfully ' . $cache_file);
            }

        }

    }

    public static function getModuleConfigInputfields(array $data)
    {
        $data = array_merge(self::$defaults, $data);

        $fields = new InputfieldWrapper();
        $modules = wire('modules');

        $field = $modules->get('InputfieldText');
        $field->attr('name', 'apikey');
        $field->attr('size', 10);
        $field->attr('value', $data['apikey']);
        // $field->set('collapsed',Inputfield::collapsedHidden);
        $field->label = 'modules.processwire.com APIkey';
        $fields->append($field);

        $field = $modules->get('InputfieldText');
        $field->attr('name', 'remoteurl');
        $field->attr('size', 0);
        $field->attr('value', $data['remoteurl']);
        $field->label = 'URL to webservice';
        $fields->append($field);

        $field = $modules->get('InputfieldInteger');
        $field->attr('name', 'limit');
        $field->attr('value', $data['limit']);
        $field->label = 'Limit';
        $fields->append($field);

        $field = $modules->get('InputfieldInteger');
        $field->attr('name', 'max_redirects');
        $field->attr('value', $data['max_redirects']);
        $field->label = 'Max Redirects for file_get_contents stream context (in case)';
        $fields->append($field);

        return $fields;
    }
}
